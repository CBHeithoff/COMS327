Assignment 1.03 involves implementing a path-finding algorithm for monsters to find the shortest path to the PC from anywhere in the dungeon. There are two version, one for monsters that can tunnel through rock and one for non-tunneling monsters. Both cases will use Dijkstra's Algorithm by turning the dungeon cells into a graph. my codebase for hw 1.03 is built on my submission for hw 1.02, so it uses the post-hw 1.01 code drop from the professor, including the files heap.c, heap.h, the dungeon generation aspect of rlg327.c, and a Makefile, so the execution is: "./rlg327 [seed] [--load|--save]", and I did not use anything from the professor's post-hw 1.02 code drop. 

For my implementation, I used the Fibonacci queue given by the professor as the needed pripority queue and built my two path-finding funtions called, dijkstra_path() and dijkstra_path_tunneling(), off of the dijkstra_corridor() function given by the professor. The algorithms works by assigning an infinite cost (INT_MAX) to all cells of the dungeon except the PC (= 0) then inserting the cells as nodes in the pripority queue. dijkstra_path() takes all rooms and corridors, while dijkstra_path_tunneling() also includes rocks. The algorithm iterates through every node comparing the weight of its surrounding eight nodes and replacing costs if a shorter distance is found. When the algorithm processes every node, a cost/distance has been calculated and can be printed out. Upon execution, the dungeon terrain map, distance map for non-tunneling monsters, and the distance map for tunneling monsters.




