Assignment 1.04 involves implementing the turn-by-turn game style and monster behavior. The codebase for hw 1.04 is built on the post-hw 1.03 code drop from the professor. I didn't modify the Makefile so the execution is: "make" THEN "./rlg327 [-n|--nummon <number of monsters>]" along with the available -s, -l, and -r flags.

For the implemention of the discrete event simulator for the game style, I used the same priority queue used for the dijkstra algorithms. I fed the heap pointers to all the monster structs containing their info and the PC struct. The heap comparator is based on character's next_turn value (increases based on speed) and their sequence number as a tie breaker. The game loop function repeatively pulls out the character whose turn is next. The PC move to the closest dungeon corner and monster will behave based on their given characteristics. When the turn is over, the character is reinserted back into the heap with an updated info and next_turn value.

The monster behavior aligns with the instruction descriptions but generally monster logic is as follows:

    1. Determine where the monster thinks/knows the PC is located given TELEPATHIC and/or SMART or neither (default is the monster position itself, meaning no movement).
    2. Determine where the monster wants its next move to be given ERRATIC/TUNNELER (random move) or SMART/TUNNELER (use dijkstra maps) or other (use bresendam for straight line).
    3. Determine the outcome of the monster's movement. If it is an open room/hallway it could be then a simple step, killing another monster, or killing the PC (ends game). If it is a wall and its a TUNNELER then break/damage the wall possibly creating hallway or if its not a TUNNELER do nothing.